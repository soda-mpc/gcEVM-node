package vm

import (
	"bytes"
	"context"
	"crypto/aes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"os"
	"strconv"

	"github.com/holiman/uint256"
	"google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	"google.golang.org/grpc/connectivity"
	"google.golang.org/grpc/credentials/insecure"
	status "google.golang.org/grpc/status"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/log"
)

// This file contains the implementation for interacting with the MPC service.
// The MPC service is used to execute operations on secret variables via MPC.
// The MPC service is implemented as a gRPC service, which defined in the mpcService.proto file.
// The gRPC client is created using the generated client code from the proto file.
// The gRPC client is used to call the methods of the MPC service.
// In order to generate the client code, the protoc compiler is used with the Go plugin
// using the command: protoc -I=/usr/local/include:. --go_out=core/vm --go-grpc_out=core/vm soda-mpc/rpc/mpcService.proto
// from the root directory of the go-ethereum repository.

type ExecutionType string

const (
	// This execution type is for generating and inserting RED blocks, it is used by the Sequencer for
	// generation and by the Executors for insertion.
	Sequencing ExecutionType = "Sequencing"
	// This execution type is for allowing non-executor nodes to insert BLACK blocks (generated by the
	// Executors via MPC).
	TranscriptEvaluation ExecutionType = "TranscriptEvaluation"
	// This execution type is for the Executors alone, it is used to execute transactions with secret
	// variables via MPC to generate a BLACK block.
	MPCExecution ExecutionType = "MPCExecution"
)

// =============================== soda mpc extended precompiles ================================================

// In this code, function signatures, such as `signatureAdd`, uniquely identify various operations
// and are created using the `makeKeccakSignature` function.
// Corresponding binary operation functions, like `additionOperation`, perform mathematical operations
// A map named `operationMap` associates each signature with its corresponding binary operation function.
// The `RunBinaryOperation` function utilizes this map, allowing dynamic selection
// of operations based on incoming signatures. The `Run` function of the precompile contract extracts the
// signature from the input, uses it to invoke `RunBinaryOperation`, and handles various functions passed
// to the precompile contract.
// This modular approach enhances code organization and maintainability by separating operations, signatures,
// and the logic for their execution.
func makeKeccakSignature(input string) uint32 {
	return binary.BigEndian.Uint32(crypto.Keccak256([]byte(input))[0:4])
}

var (
	// Function signatures
	signatureOnboard                = makeKeccakSignature("OnBoard(bytes1,uint256)")
	signatureOffboard               = makeKeccakSignature("OffBoard(bytes1,uint256)")
	signatureOffboardToUser         = makeKeccakSignature("OffBoardToUser(bytes1,uint256,bytes)")
	signatureSetPublic              = makeKeccakSignature("SetPublic(bytes1,uint256)")
	signatureAdd                    = makeKeccakSignature("Add(bytes3,uint256,uint256)")
	signatureCheckedAdd             = makeKeccakSignature("CheckedAdd(bytes3,uint256,uint256)")
	signatureSub                    = makeKeccakSignature("Sub(bytes3,uint256,uint256)")
	signatureCheckedSub             = makeKeccakSignature("CheckedSub(bytes3,uint256,uint256)")
	signatureMul                    = makeKeccakSignature("Mul(bytes3,uint256,uint256)")
	signatureCheckedMul             = makeKeccakSignature("CheckedMul(bytes3,uint256,uint256)")
	signatureLe                     = makeKeccakSignature("Le(bytes3,uint256,uint256)")
	signatureLt                     = makeKeccakSignature("Lt(bytes3,uint256,uint256)")
	signatureEq                     = makeKeccakSignature("Eq(bytes3,uint256,uint256)")
	signatureGe                     = makeKeccakSignature("Ge(bytes3,uint256,uint256)")
	signatureGt                     = makeKeccakSignature("Gt(bytes3,uint256,uint256)")
	signatureShl                    = makeKeccakSignature("Shl(bytes3,uint256,uint256)")
	signatureShr                    = makeKeccakSignature("Shr(bytes3,uint256,uint256)")
	signatureNe                     = makeKeccakSignature("Ne(bytes3,uint256,uint256)")
	signatureMin                    = makeKeccakSignature("Min(bytes3,uint256,uint256)")
	signatureMax                    = makeKeccakSignature("Max(bytes3,uint256,uint256)")
	signatureNot                    = makeKeccakSignature("Not(bytes1,uint256)")
	signatureDiv                    = makeKeccakSignature("Div(bytes3,uint256,uint256)")
	signatureRem                    = makeKeccakSignature("Rem(bytes3,uint256,uint256)")
	signatureBitAnd                 = makeKeccakSignature("And(bytes3,uint256,uint256)")
	signatureBitOr                  = makeKeccakSignature("Or(bytes3,uint256,uint256)")
	signatureBitXor                 = makeKeccakSignature("Xor(bytes3,uint256,uint256)")
	signatureMux                    = makeKeccakSignature("Mux(bytes3,uint256,uint256,uint256)")
	signatureDecrypt                = makeKeccakSignature("Decrypt(bytes1,uint256)")
	signatureTransfer               = makeKeccakSignature("Transfer(bytes4,uint256,uint256,uint256)")
	signatureGetKey                 = makeKeccakSignature("GetUserKey(bytes)")
	signatureValidateCiphertext     = makeKeccakSignature("ValidateCiphertext(bytes1,uint256,bytes)")
	signatureTransferWithAllowance  = makeKeccakSignature("TransferWithAllowance(bytes5,uint256,uint256,uint256,uint256)")
	signatureRand                   = makeKeccakSignature("Rand(bytes1)")
	signatureRandBoundedBits        = makeKeccakSignature("RandBoundedBits(bytes1,uint8)")
	signatureSHA256Fixed432BitInput = makeKeccakSignature("SHA256Fixed432BitInput(uint256,uint256,uint256,uint256,uint256,bytes)")

	// Map signatures to functions names.
	operationNamesMap = map[uint32]string{
		signatureAdd:                    "ADD",
		signatureCheckedAdd:             "ADDWITHOVERFLOWBIT", // The name is different from the signature name because is has to be the MPC circuit's name
		signatureSub:                    "SUB",
		signatureCheckedSub:             "SUBWITHOVERFLOWBIT", // The name is different from the signature name because is has to be the MPC circuit's name
		signatureMul:                    "MUL",
		signatureCheckedMul:             "MULWITHOVERFLOWBIT", // The name is different from the signature name because is has to be the MPC circuit's name
		signatureLe:                     "LE",
		signatureLt:                     "LT",
		signatureEq:                     "EQ",
		signatureGe:                     "GE",
		signatureGt:                     "GT",
		signatureNe:                     "NE",
		signatureMin:                    "MIN",
		signatureMax:                    "MAX",
		signatureDiv:                    "DIV",
		signatureRem:                    "REM",
		signatureBitAnd:                 "AND",
		signatureBitOr:                  "OR",
		signatureBitXor:                 "XOR",
		signatureShl:                    "SHL",
		signatureShr:                    "SHR",
		signatureOnboard:                "ONBOARD",
		signatureValidateCiphertext:     "ONBOARD",
		signatureOffboard:               "OFFBOARD",
		signatureOffboardToUser:         "OFFBOARD",
		signatureSetPublic:              "SETPUBLIC",
		signatureRand:                   "RAND",
		signatureRandBoundedBits:        "RAND",
		signatureDecrypt:                "DECRYPT",
		signatureMux:                    "MUX",
		signatureNot:                    "NOT",
		signatureTransfer:               "TRANSFER",
		signatureTransferWithAllowance:  "TRANSFERWITHALLOWANCE",
		signatureGetKey:                 "GETUSERKEY",
		signatureSHA256Fixed432BitInput: "SHA256FIXED432BITINPUT",
	}

	// requiredGasMap maps a function signature along with the number of bits to the corresponding required gas value.
	requiredGasMap = map[struct {
		signature uint32
		bits      int
	}]uint64{
		{signature: signatureBitAnd, bits: 1}:                 12005,
		{signature: signatureBitOr, bits: 1}:                  12005,
		{signature: signatureSetPublic, bits: 1}:              12000,
		{signature: signatureDecrypt, bits: 1}:                12000,
		{signature: signatureBitXor, bits: 1}:                 12000,
		{signature: signatureMin, bits: 1}:                    12010,
		{signature: signatureMax, bits: 1}:                    12010,
		{signature: signatureLt, bits: 1}:                     12005,
		{signature: signatureGt, bits: 1}:                     12010,
		{signature: signatureGe, bits: 1}:                     12005,
		{signature: signatureLe, bits: 1}:                     12010,
		{signature: signatureEq, bits: 1}:                     12000,
		{signature: signatureNe, bits: 1}:                     12000,
		{signature: signatureNot, bits: 1}:                    12000,
		{signature: signatureMux, bits: 1}:                    12005,
		{signature: signatureOnboard, bits: 1}:                47039,
		{signature: signatureValidateCiphertext, bits: 1}:     47039,
		{signature: signatureOffboard, bits: 1}:               47039,
		{signature: signatureOffboardToUser, bits: 1}:         47039,
		{signature: signatureBitAnd, bits: 8}:                 12040,
		{signature: signatureBitOr, bits: 8}:                  12042,
		{signature: signatureSetPublic, bits: 8}:              12000,
		{signature: signatureDecrypt, bits: 8}:                12000,
		{signature: signatureBitXor, bits: 8}:                 12000,
		{signature: signatureAdd, bits: 8}:                    12037,
		{signature: signatureCheckedAdd, bits: 8}:             12037,
		{signature: signatureSub, bits: 8}:                    12080,
		{signature: signatureCheckedSub, bits: 8}:             12080,
		{signature: signatureMul, bits: 8}:                    12620,
		{signature: signatureCheckedMul, bits: 8}:             12620,
		{signature: signatureDiv, bits: 8}:                    12969,
		{signature: signatureRem, bits: 8}:                    12969,
		{signature: signatureMin, bits: 8}:                    12121,
		{signature: signatureMax, bits: 8}:                    12121,
		{signature: signatureLt, bits: 8}:                     12080,
		{signature: signatureGt, bits: 8}:                     12121,
		{signature: signatureGe, bits: 8}:                     12080,
		{signature: signatureLe, bits: 8}:                     12122,
		{signature: signatureEq, bits: 8}:                     12037,
		{signature: signatureNe, bits: 8}:                     12037,
		{signature: signatureTransfer, bits: 8}:               12201,
		{signature: signatureTransferWithAllowance, bits: 8}:  12301,
		{signature: signatureMux, bits: 8}:                    12041,
		{signature: signatureOnboard, bits: 8}:                47039,
		{signature: signatureValidateCiphertext, bits: 8}:     47039,
		{signature: signatureOffboard, bits: 8}:               47040,
		{signature: signatureOffboardToUser, bits: 8}:         47040,
		{signature: signatureBitAnd, bits: 16}:                12080,
		{signature: signatureBitOr, bits: 16}:                 12084,
		{signature: signatureSetPublic, bits: 16}:             12001,
		{signature: signatureDecrypt, bits: 16}:               12001,
		{signature: signatureBitXor, bits: 16}:                12001,
		{signature: signatureAdd, bits: 16}:                   12080,
		{signature: signatureCheckedAdd, bits: 16}:            12080,
		{signature: signatureSub, bits: 16}:                   12165,
		{signature: signatureCheckedSub, bits: 16}:            12165,
		{signature: signatureMul, bits: 16}:                   14571,
		{signature: signatureCheckedMul, bits: 16}:            14571,
		{signature: signatureDiv, bits: 16}:                   15960,
		{signature: signatureRem, bits: 16}:                   15960,
		{signature: signatureMin, bits: 16}:                   12249,
		{signature: signatureMax, bits: 16}:                   12249,
		{signature: signatureLt, bits: 16}:                    12166,
		{signature: signatureGt, bits: 16}:                    12249,
		{signature: signatureGe, bits: 16}:                    12165,
		{signature: signatureLe, bits: 16}:                    12249,
		{signature: signatureEq, bits: 16}:                    12079,
		{signature: signatureNe, bits: 16}:                    12079,
		{signature: signatureTransfer, bits: 16}:              12413,
		{signature: signatureTransferWithAllowance, bits: 16}: 12619,
		{signature: signatureMux, bits: 16}:                   12083,
		{signature: signatureOnboard, bits: 16}:               47039,
		{signature: signatureValidateCiphertext, bits: 16}:    47039,
		{signature: signatureOffboard, bits: 16}:              47040,
		{signature: signatureOffboardToUser, bits: 16}:        47040,
		{signature: signatureBitAnd, bits: 32}:                12160,
		{signature: signatureBitOr, bits: 32}:                 12169,
		{signature: signatureSetPublic, bits: 32}:             12003,
		{signature: signatureDecrypt, bits: 32}:               12003,
		{signature: signatureBitXor, bits: 32}:                12003,
		{signature: signatureAdd, bits: 32}:                   12167,
		{signature: signatureCheckedAdd, bits: 32}:            12167,
		{signature: signatureSub, bits: 32}:                   12337,
		{signature: signatureCheckedSub, bits: 32}:            12337,
		{signature: signatureMul, bits: 32}:                   22467,
		{signature: signatureCheckedMul, bits: 32}:            22467,
		{signature: signatureDiv, bits: 32}:                   28009,
		{signature: signatureRem, bits: 32}:                   28009,
		{signature: signatureMin, bits: 32}:                   12503,
		{signature: signatureMax, bits: 32}:                   12503,
		{signature: signatureLt, bits: 32}:                    12337,
		{signature: signatureGt, bits: 32}:                    12503,
		{signature: signatureGe, bits: 32}:                    12337,
		{signature: signatureLe, bits: 32}:                    12503,
		{signature: signatureEq, bits: 32}:                    12164,
		{signature: signatureNe, bits: 32}:                    12164,
		{signature: signatureTransfer, bits: 32}:              12837,
		{signature: signatureTransferWithAllowance, bits: 32}: 13255,
		{signature: signatureMux, bits: 32}:                   12166,
		{signature: signatureOnboard, bits: 32}:               47039,
		{signature: signatureValidateCiphertext, bits: 32}:    47039,
		{signature: signatureOffboard, bits: 32}:              47042,
		{signature: signatureOffboardToUser, bits: 32}:        47042,
		{signature: signatureBitAnd, bits: 64}:                12320,
		{signature: signatureBitOr, bits: 64}:                 12339,
		{signature: signatureSetPublic, bits: 64}:             12006,
		{signature: signatureDecrypt, bits: 64}:               12006,
		{signature: signatureBitXor, bits: 64}:                12006,
		{signature: signatureAdd, bits: 64}:                   12340,
		{signature: signatureCheckedAdd, bits: 64}:            12340,
		{signature: signatureSub, bits: 64}:                   12679,
		{signature: signatureCheckedSub, bits: 64}:            12679,
		{signature: signatureMul, bits: 64}:                   54233,
		{signature: signatureCheckedMul, bits: 64}:            54233,
		{signature: signatureDiv, bits: 64}:                   76377,
		{signature: signatureRem, bits: 64}:                   76377,
		{signature: signatureMin, bits: 64}:                   13012,
		{signature: signatureMax, bits: 64}:                   13012,
		{signature: signatureLt, bits: 64}:                    12679,
		{signature: signatureGt, bits: 64}:                    13012,
		{signature: signatureGe, bits: 64}:                    12679,
		{signature: signatureLe, bits: 64}:                    13012,
		{signature: signatureEq, bits: 64}:                    12334,
		{signature: signatureNe, bits: 64}:                    12334,
		{signature: signatureTransfer, bits: 64}:              13685,
		{signature: signatureTransferWithAllowance, bits: 64}: 14527,
		{signature: signatureMux, bits: 64}:                   12332,
		{signature: signatureOnboard, bits: 64}:               47039,
		{signature: signatureValidateCiphertext, bits: 64}:    47039,
		{signature: signatureOffboard, bits: 64}:              47045,
		{signature: signatureOffboardToUser, bits: 64}:        47045,
		{signature: signatureGetKey}:                          47039,
		{signature: signatureShl, bits: 8}:                    12620,
		{signature: signatureShl, bits: 16}:                   14571,
		{signature: signatureShl, bits: 32}:                   22467,
		{signature: signatureShl, bits: 64}:                   54233,
		{signature: signatureShr, bits: 8}:                    12969,
		{signature: signatureShr, bits: 16}:                   15960,
		{signature: signatureShr, bits: 32}:                   28009,
		{signature: signatureShr, bits: 64}:                   76377,
		{signature: signatureRand, bits: 1}:                   6000,
		{signature: signatureRand, bits: 8}:                   6000,
		{signature: signatureRand, bits: 16}:                  6000,
		{signature: signatureRand, bits: 32}:                  6000,
		{signature: signatureRand, bits: 64}:                  6000,
		{signature: signatureRandBoundedBits, bits: 8}:        6000,
		{signature: signatureRandBoundedBits, bits: 16}:       6000,
		{signature: signatureRandBoundedBits, bits: 32}:       6000,
		{signature: signatureRandBoundedBits, bits: 64}:       6000,
		{signature: signatureSHA256Fixed432BitInput}:          120000,
	}
)

var (
	ErrMPCConnection          = errors.New("MPC connection failed")                                      // restart
	ErrMPCExecution           = errors.New("MPC execution failed")                                       // restart
	ErrMPCUnknownError        = errors.New("MPC execution failed due to unknown error")                  // panic
	ErrMPCMaliciousError      = errors.New("MPC execution failed due to malicious error")                // panic
	ErrMPCHashNotFoundError   = errors.New("MPC hash not found")                                         // revert
	ErrAllocatingMemory       = errors.New("error allocating memory")                                    // panic
	ErrRunCalledOnEVMAware    = errors.New("run should not be called on an EVMAwarePrecompiledContract") // revert
	ErrEVMIsNIL               = errors.New("EVM is nil")                                                 // revert
	ErrInvalidCall            = errors.New("invalid call of a precompiled contract in an eth_call")      // log only
	ErrInvalidExecutionType   = errors.New("invalid execution type")                                     // panic
	ErrInvalidInputFormat     = errors.New("invalid input format")                                       // revert
	ErrNegativeNumberOfSlices = errors.New("number of slices must be positive")                          // revert
	ErrVerifySignature        = errors.New("error verifying signature")                                  // revert
	ErrInavlidCallDepth       = errors.New("invalid call depth")                                         // revert
	ErrInvalidSignature       = errors.New("invalid signature")                                          // revert
	ErrInvalidEVMByteArray    = errors.New("input is not a valid EVM byte array")                        // revert
	ErrInvalidCT              = errors.New("invalid cipher-text")                                        // revert
	ErrMethodNotFound         = errors.New("method not found")                                           // revert
	ErrInvalidArgument        = errors.New("invalid argument in MPC")                                    // revert

	// Map mpc results to mpc errors.
	MPCExecutionResult = map[string]error{
		"CONNECTION_ERROR":     ErrMPCConnection,
		"EXECUTION_ERROR":      ErrMPCExecution,
		"MALICIOUS_ERROR":      ErrMPCMaliciousError,
		"BAD_ALLOCATION_ERROR": ErrAllocatingMemory,
		"HASH_NOT_FOUND_ERROR": ErrMPCHashNotFoundError,
		"INVALID_ARGUMENT":     ErrInvalidArgument,
		"OTHER_ERROR":          ErrMPCUnknownError,
	}

	MPCUnrecoverableErrors = map[error]bool{
		ErrMPCUnknownError:         true,
		ErrMPCMaliciousError:       true,
		ErrAllocatingMemory:        true,
		ErrInvalidExecutionType:    true,
		types.ErrTranscriptIsEmpty: true,
	}
	MPCTxReversionErrors = map[error]bool{
		ErrInvalidInputFormat:     true,
		ErrNegativeNumberOfSlices: true,
		ErrVerifySignature:        true,
		ErrInavlidCallDepth:       true,
		ErrInvalidSignature:       true,
		ErrInvalidEVMByteArray:    true,
		ErrInvalidCT:              true,
		ErrMethodNotFound:         true,
		ErrExecutionReverted:      true,
		ErrInvalidArgument:        true,
		ErrMPCHashNotFoundError:   true,
		ErrRunCalledOnEVMAware:    true,
		ErrEVMIsNIL:               true,
	}

	revertOutput = crypto.Keccak256([]byte(string("reverted")))
)

const (
	FUNC_SIG_SIZE             = 4 // First 4 bytes of keccak256 on the function signature
	BINARY_MD_SIZE            = 3 // 3 for metadata: one for size of each parameter (lhs and rhs) and one for operands being scalars
	UNIRY_MD_SIZE             = 1 // 1 for metadata size
	TRANSFER_MD_SIZE          = 4 // 4 for metadata: one for size of each parameter (lhs, rhs, amount) and one for amount being scalar
	TRANSFERALLOWANCE_MD_SIZE = 5 // 5 for metadata: one for size of each parameter (lhs, rhs, amount, allowance) and one for amount being scalar
	VAR_SIZE                  = 32
	// Although the actual metadata size is smaller than 32 bytes, in Ethereum, data is typically padded to 32 bytes. Solidity pads data to 32 bytes for better alignment and compatibility with the EVM (Ethereum Virtual Machine).
	// This behavior is consistent with the standard Ethereum ABI encoding rules, which dictate that dynamic types (like bytes) are always 32 bytes or a multiple of 32 bytes.
	// As a result, the size of metadata remains the same, regardless of whether the transmitted data from Solidity ranges from bytes1 to bytes32.
	// Within these 32 bytes, the first bytes will be the actual metadata value (for example, for binary functions it will be 3 bytes), and the remaining bytes will be padding with zeros.
	METADATA_SIZE           = 32
	SIGNATURE_SIZE          = 65  // 65 bytes for ECDSA signature
	SIGNATURE_PADDING_SIZE  = 31  // 31 bytes for signature padding
	MIN_RSA_PUBLIC_KEY_SIZE = 257 // 257 bytes for RSA public key
	MAX_RSA_PUBLIC_KEY_SIZE = 512 // 512 bytes for RSA public key
	EVM_BYTES_PREFIX_SIZE   = 64  // 64 bytes for bytes prefix
	ADDR_SIZE               = 20  // 20 bytes for address
	ADDR_PADDING_SIZE       = 12  // 12 bytes for address padding
	RSA_OUTPUT_SIZE         = 256 // 32 bytes for RSA encryption
	GAS_ESTIMATE_RAND_SIZE  = 8   // The size of the chosen randon variable
	CIPHER_TEXT_SIZE        = 32
)

const (
	BOTH_SECRET = iota
	LHS_PUBLIC
	RHS_PUBLIC
)

const (
	SBOOL_T   = iota // 1-bits size parameter
	SUINT8_T         // 8-bits size parameter
	SUINT16_T        // 16-bits size parameter
	SUINT32_T        // 32-bits size parameter
	SUINT64_T        // 64-bits size parameter
)

const MESSAGE_PREFIX = "\u0019Ethereum Signed Message:\n"

var client MPCServiceClient
var clientCreated bool = false
var conn *grpc.ClientConn

func CreateMPCService() error {
	log.Debug("CreateMPCService")
	// Create a context for the RPC call
	ctx := context.Background()

	var serverPort = common.MpcServerPort
	var ip = common.MpcServerIP

	log.Debug("CallMPCService - Dialing the gRPC server at:", "IP", ip, "serverPort", serverPort)
	// Dial the gRPC server (asynchronous connection)

	for {
		var err error
		conn, err = grpc.DialContext(ctx, ip+":"+serverPort, grpc.WithTransportCredentials(insecure.NewCredentials()))
		if err != nil {
			log.Error("CallMPCService - client did not connect: ", "error", err)
		} else {
			break
		}
	}

	err := waitForReadyServer()
	if err != nil {
		log.Error("CallMPCService - Connection failed")
		return err
	}

	log.Debug("CallMPCService - Connection established")

	// Create a new gRPC evaluator client
	client = NewMPCServiceClient(conn)
	clientCreated = true

	return nil
}

func waitForReadyServer() error {
	// Wait until the connection is ready
	// Create a context for the RPC call
	ctx := context.Background()
	for {
		state := conn.GetState()
		if state == connectivity.Ready {
			log.Debug("CallMPCService - Connection is ready")
			break
		}

		log.Debug("CallMPCService - Current connection state: ", "state", state)

		// Wait for the connection state to change
		if !conn.WaitForStateChange(ctx, state) {
			log.Error("CallMPCService - Connection failed to reach ready state in time")
			return ErrMPCConnection
		}
	}

	return nil
}

func GetMPCStatus() *types.MPCStatus {
	log.Debug("GetMPCStatus")

	// Create a context for the RPC call
	ctx := context.Background()

	// Prepare the request
	request := &GetMPCStatusRequest{}

	// Call the rpc GetMPCStatus method
	response, err := client.GetMPCStatus(ctx, request)
	for err != nil {
		log.Error("GetMPCStatus - could not run MPC", "error", err)
		if st, ok := status.FromError(err); ok && st.Code() == codes.Unavailable {
			// Print the error message sent from the server
			log.Error("GetMPCStatus - gRPC error occurred", "code", st.Code(), "message", st.Message())
			waitErr := waitForReadyServer()
			if waitErr != nil {
				log.Error("GetMPCStatus - Connection failed")
				return nil
			} else {
				response, err = client.GetMPCStatus(ctx, request)
			}
		} else {
			log.Error("GetMPCStatus - error in gRPC", "error", err)
			return nil
		}
	}

	if response == nil {
		log.Error("GetMPCStatus - response is nil")
		return nil
	}

	if response.ResultCode != 0 {
		log.Error("GetMPCStatus error", "result code", response.ResultCode)
		return nil
	}

	// Create a new MPCStatus and populate it with values from the gRPC response
	status := &types.MPCStatus{
		OpcodesNames:        response.CircuitsNames,
		BatchIds:            response.BatchIds,
		CircuitsInsideBatch: response.CircuitInBatches,
	}
	log.Debug("Get MPC status", "opcodes", status.OpcodesNames, "batch ids", status.BatchIds, "circuit in batch", status.CircuitsInsideBatch)

	return status
}

func SetInitialMPCStatus() {
	log.Debug("SetInitialMPCStatus")
	if !clientCreated {
		log.Debug("SetInitialMPCStatus - client not created")
		CreateMPCService()
	}

	// Create a context for the RPC call
	ctx := context.Background()

	// Prepare the request
	request := &InitMPCStatusRequest{}

	// Call the rpc SetMPCStatus method
	response, err := client.InitMPCStatus(ctx, request)
	for err != nil {
		log.Error("SetInitialMPCStatus - could not run MPC", "error", err)
		if st, ok := status.FromError(err); ok && st.Code() == codes.Unavailable {
			// Print the error message sent from the server
			log.Error("SetInitialMPCStatus - gRPC error occurred", "code", st.Code(), "message", st.Message())
			waitErr := waitForReadyServer()
			if waitErr != nil {
				log.Error("SetInitialMPCStatus - Connection failed")
			} else {
				response, err = client.InitMPCStatus(ctx, request)
			}
		} else {
			log.Error("SetInitialMPCStatus - error in gRPC", "error", err)
		}
	}

	if response == nil {
		log.Error("SetMPCStatus - response is nil")
	}

	if response.ResultCode != 0 {
		log.Error("SetMPCStatus error", "result code", response.ResultCode)
	}
}

func SetMPCStatus(mpcStatus *types.MPCStatus) error {
	log.Debug("SetMPCStatus")
	if !clientCreated {
		CreateMPCService()
	}

	// Create a context for the RPC call
	ctx := context.Background()

	// Prepare the request
	request := &SetMPCStatusRequest{
		CircuitsNames:    mpcStatus.OpcodesNames,
		BatchIds:         mpcStatus.BatchIds,
		CircuitInBatches: mpcStatus.CircuitsInsideBatch,
	}

	// Call the rpc SetMPCStatus method
	response, err := client.SetMPCStatus(ctx, request)
	for err != nil {
		log.Error("SetMPCStatus - could not run MPC", "error", err)
		if st, ok := status.FromError(err); ok && st.Code() == codes.Unavailable {
			// Print the error message sent from the server
			log.Error("SetMPCStatus - gRPC error occurred", "code", st.Code(), "message", st.Message())
			waitErr := waitForReadyServer()
			if waitErr != nil {
				log.Error("SetMPCStatus - Connection failed")
			} else {
				response, err = client.SetMPCStatus(ctx, request)
			}
		} else {
			log.Error("SetMPCStatus - error in gRPC", "error", err)
		}
	}

	if response == nil {
		log.Error("SetMPCStatus - response is nil")
		return nil
	}

	if response.ResultCode != 0 {
		log.Error("SetMPCStatus error", "result code", response.ResultCode)
		return nil
	}

	log.Debug("Set MPC status", "opcodes", mpcStatus.OpcodesNames, "batch ids", mpcStatus.BatchIds, "circuit in batch", mpcStatus.CircuitsInsideBatch)

	return nil
}

func checkScalarInput(parameter []byte, parameterBitSize uint32) bool {
	// Get the number of bytes for the given parameter
	numBytes := (int(parameterBitSize) + 7) / 8 // Round up to the nearest byte

	// Checks that the given parameter is not bigger than the expected size
	// by checking the MSB of the parameter
	for i := 0; i < len(parameter)-numBytes; i++ {
		if parameter[i] != 0 {
			log.Error("Found invalid value", "index", i, "parameter", parameter[i])
			return false
		}
	}
	return true
}

func validateScalarInputs(opName string, parametersBitSize []uint32, inputTypes byte, parameters [][]byte) bool {
	// Check input parameters values in case of scalar input
	if opName != "MUX" && opName != "TRANSFER" && opName != "TRANSFERWITHALLOWANCE" {
		if inputTypes == LHS_PUBLIC {
			if !checkScalarInput(parameters[0], parametersBitSize[0]) {
				log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[0])
				return false
			}
		}
		if inputTypes == RHS_PUBLIC {
			if !checkScalarInput(parameters[1], parametersBitSize[1]) {
				log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[1])
				return false
			}
		}
	}
	if opName == "MUX" {
		if inputTypes == LHS_PUBLIC {
			if !checkScalarInput(parameters[1], parametersBitSize[1]) {
				log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[0])
				return false
			}
		}
		if inputTypes == RHS_PUBLIC {
			if !checkScalarInput(parameters[2], parametersBitSize[2]) {
				log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[1])
				return false
			}
		}
	}
	if opName == "TRANSFER" || opName == "TRANSFERWITHALLOWANCE" {
		// In the context of a transfer, scalar balances are irrelevant;
		// The only possibility for a scalar value is within the "amount" parameter.
		// Therefore, in this scenario, BOTH_SECRET signifies a secret amount. Any other value, signifies a scalar amount.
		if inputTypes == LHS_PUBLIC || inputTypes == RHS_PUBLIC {
			if !checkScalarInput(parameters[2], parametersBitSize[2]) {
				log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[0])
				return false
			}
		}
	}
	if opName == "SETPUBLIC" {
		if !checkScalarInput(parameters[0], parametersBitSize[0]) {
			log.Error("ValidateScalarInputs - invalid scalar input", "parameter", parameters[0])
			return false
		}
	}

	return true
}

func validateArguments(opName string, parametersBitSize []uint32, numInputs int, inputTypes byte, parameters [][]byte) bool {
	// Validates that the number of inputs is not negative
	if numInputs < 0 {
		log.Error("ValidateArguments - invalid number of inputs", "numInputs", numInputs)
		return false
	}

	// Set the number of parameters bit size for each operation
	var numParametersBitSize int
	switch opName {
	case "GETUSERKEY", "SHA256FIXED432BITINPUT":
		numParametersBitSize = 0 // In these cases, the parameter sizes are not relevant
	case "ONBOARD", "OFFBOARD", "RAND":
		numParametersBitSize = 1 // In these cases, the parameter sizes is always one, regardless of the number of inputs
	default:
		numParametersBitSize = numInputs
	}

	// Validate the number of parameters bit size
	if len(parametersBitSize) != numParametersBitSize {
		log.Error("ValidateArguments - invalid number of parameters bit size", "numParametersBitSize", numParametersBitSize, "parametersBitSize", len(parametersBitSize))
		return false
	}

	// Checks that each bit size is valid
	var HasBoolParameter bool = false
	var hasIntParameter bool = false
	for i := 0; i < numParametersBitSize; i++ {
		if parametersBitSize[i] != 1 && parametersBitSize[i] != 8 && parametersBitSize[i] != 16 && parametersBitSize[i] != 32 && parametersBitSize[i] != 64 && parametersBitSize[i] != 128 {
			log.Error("ValidateArguments - invalid parameter bit size", "index", i)
			return false
		}
		if parametersBitSize[i] == 1 {
			HasBoolParameter = true
		} else {
			hasIntParameter = true
		}

		// There is no operation that can have both bool and int bit sizes
		if HasBoolParameter && hasIntParameter && opName != "MUX" {
			log.Error("ValidateArguments - cannot have both bool and int parameters", "opName", opName)
			return false
		}
	}

	// Validates the input types
	if inputTypes != BOTH_SECRET && inputTypes != LHS_PUBLIC && inputTypes != RHS_PUBLIC {
		log.Error("ValidateArguments - invalid input type", "inputTypes", inputTypes)
		return false
	}

	// Checks that the number of parameters is correct
	if len(parameters) != numInputs {
		log.Error("ValidateArguments - invalid number of parameters", "numInputs", numInputs, "parameters", len(parameters))
		return false
	}

	// Checks that each parameter is not empty
	for i := 0; i < numInputs; i++ {
		if len(parameters[i]) == 0 {
			log.Error("ValidateArguments - invalid parameter", "index", i)
			return false
		}
	}

	if !validateScalarInputs(opName, parametersBitSize, inputTypes, parameters) {
		log.Error("ValidateArguments - invalid scalar inputs")
		return false
	}

	return true
}

func runOpcode(opName string, parametersBitSize []uint32, numInputs int, inputTypes byte, parameters [][]byte) ([]byte, error) {
	// Create a context for the RPC call
	ctx := context.Background()

	// Validate the arguments
	if !validateArguments(opName, parametersBitSize, numInputs, inputTypes, parameters) {
		return nil, ErrInvalidInputFormat
	}

	// Prepare the request
	request := &MPCRequest{
		OpName:            opName,
		NumInputs:         uint32(numInputs),
		ParametersBitSize: parametersBitSize,
		InputTypes:        []byte{inputTypes},
		Parameters:        parameters,
	}

	// Call the RunMPC method
	response, err := client.RunMPC(ctx, request)
	if err != nil {
		log.Error("RunOpcode - could not run MPC", "error", err)
		st, ok := status.FromError(err)
		if ok {
			// Print the error message sent from the server
			log.Error("GRPC error occurred", "code", st.Code(), "message", st.Message())

			if st.Code() == codes.Unavailable { // The server is not available
				return nil, ErrMPCConnection
			}

			mpcResult := MPCExecutionResult[st.Message()]
			if mpcResult == nil {
				return nil, ErrMPCUnknownError
			}
			return nil, mpcResult
		} else {
			log.Error("RunOpcode - error in gRPC", "error", err)
			return nil, ErrMPCUnknownError
		}
	}

	if response == nil {
		log.Error("RunOpcode - response is nil")
		return nil, ErrMPCUnknownError
	}

	if response.ResultCode != 0 {
		log.Error("RunOpcode error", "result code", response.ResultCode)
		return nil, ErrMPCUnknownError
	}

	// Handle the response
	log.Debug("MPC Response:", "output", response.Output)
	return response.Output, nil
}

type mpcContract struct {
}

func (c *mpcContract) Run(input []byte) ([]byte, error) {
	log.Error("Run should not be called on an EVMAwarePrecompiledContract")
	return nil, ErrRunCalledOnEVMAware
}

func getSize(size byte) (int, error) {
	// Get the number of bits according to the relevant enum
	switch size {
	case SBOOL_T:
		return 1, nil
	case SUINT8_T:
		return 8, nil
	case SUINT16_T:
		return 16, nil
	case SUINT32_T:
		return 32, nil
	case SUINT64_T:
		return 64, nil
	default:
		return -1, ErrInvalidArgument // Impossible result
	}
}

type signatureAndBits struct {
	signature uint32
	bits      int
}

func getSignatureAndBits(input []byte) signatureAndBits {
	if input == nil {
		log.Error("Input is nil")
		return signatureAndBits{}
	}

	if len(input) < FUNC_SIG_SIZE+METADATA_SIZE {
		log.Error("Invalid input format")
		return signatureAndBits{}
	}

	signature := binary.BigEndian.Uint32(input[0:FUNC_SIG_SIZE])
	var requiredBits int
	var err error

	switch signature {
	case signatureOnboard:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureOffboard:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureOffboardToUser:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureSetPublic:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureRand:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureRandBoundedBits:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureDecrypt:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureNot:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureValidateCiphertext:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureMux:
		bits1, err1 := getSize(input[FUNC_SIG_SIZE])
		bits2, err2 := getSize(input[FUNC_SIG_SIZE+1])
		requiredBits = getMax(bits1, bits2)
		if (err1 != nil) || (err2 != nil) {
			err = ErrInvalidArgument
		}
	case signatureTransfer:
		bits1, err1 := getSize(input[FUNC_SIG_SIZE])
		bits2, err2 := getSize(input[FUNC_SIG_SIZE+1])
		bits3, err3 := getSize(input[FUNC_SIG_SIZE+2])
		requiredBits = getMax(bits1, bits2, bits3)
		if (err1 != nil) || (err2 != nil) || (err3 != nil) {
			err = ErrInvalidArgument
		}
	case signatureTransferWithAllowance:
		bits1, err1 := getSize(input[FUNC_SIG_SIZE])
		bits2, err2 := getSize(input[FUNC_SIG_SIZE+1])
		bits3, err3 := getSize(input[FUNC_SIG_SIZE+2])
		bits4, err4 := getSize(input[FUNC_SIG_SIZE+3])
		requiredBits = getMax(bits1, bits2, bits3, bits4)
		if (err1 != nil) || (err2 != nil) || (err3 != nil) || (err4 != nil) {
			err = ErrInvalidArgument
		}
	case signatureGetKey:
		requiredBits = 0
	case signatureSHA256Fixed432BitInput:
		requiredBits = 0
	case signatureShl:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	case signatureShr:
		requiredBits, err = getSize(input[FUNC_SIG_SIZE])
	default: // A binary operation
		bits1, err1 := getSize(input[FUNC_SIG_SIZE])
		bits2, err2 := getSize(input[FUNC_SIG_SIZE+1])
		requiredBits = getMax(bits1, bits2)
		if (err1 != nil) || (err2 != nil) {
			err = ErrInvalidArgument
		}
	}
	if err != nil {
		return signatureAndBits{}
	}

	key := struct {
		signature uint32
		bits      int
	}{signature: signature, bits: requiredBits}

	return key
}

func (c *mpcContract) RequiredGas(input []byte) uint64 {
	// Get the signature and the number of bits for the given operation
	key := getSignatureAndBits(input)

	// Get the required gas for the given operation
	if gas, ok := requiredGasMap[key]; ok {
		return gas
	}

	// default 0 for unknown signature or unknown size
	return 0
}

func (c *mpcContract) isSupportedOperation(input []byte) bool {
	// Get the signature and the number of bits for the given operation
	key := getSignatureAndBits(input)

	// If the operation is in the requiredGasMap, it is supported
	if _, ok := requiredGasMap[key]; ok {
		return true
	}

	log.Error("Operation not supported", "signature", key.signature, "bits", key.bits)
	return false
}

func getMax(nums ...int) int {
	if len(nums) == 0 {
		// Handle the case where no arguments are provided
		return 0
	}

	max := nums[0]
	for _, num := range nums {
		if num > max {
			max = num
		}
	}

	return max
}

// EVMAwareRun executes the MPC precompile contract's logic based on the provided input. It identifies the specific
// method using the extracted function signature and directs the execution flow to the
// corresponding operation.
// The function signatures, such as signatureAdd and others, uniquely define various operations.
func (c *mpcContract) EVMAwareRun(input []byte, evm *EVM, caller common.Address, addr common.Address) ([]byte, error) {
	if evm == nil {
		log.Error("EVM is nil")
		return nil, ErrEVMIsNIL
	}

	if input == nil {
		log.Error("Input is nil")
		return nil, ErrInvalidInputFormat
	}

	if len(input) < FUNC_SIG_SIZE+METADATA_SIZE {
		log.Error("Invalid input format")
		return nil, ErrInvalidInputFormat
	}

	signature := binary.BigEndian.Uint32(input[0:FUNC_SIG_SIZE])
	// Get the operation based on the signature
	opName, ok := operationNamesMap[signature]
	if !ok {
		log.Error("Method not found")
		evm.SetMPCError(ErrMethodNotFound)
		return nil, ErrMethodNotFound
	}

	// If the operation is not supported for the given bit size, return an error
	if !c.isSupportedOperation(input) {
		log.Error("Operation not supported for this bit size")
		return nil, ErrMethodNotFound
	}

	if evm.IsGasEstimated {
		log.Trace("Performing gas estimation")
		return c.fakeMPC(signature, evm.IsGasEstimated)
	}

	// Block view calls that are not gas estimation
	if evm.IsEthCall {
		log.Error("Invalid call of a precompiled contract in an eth_call")
		evm.SetMPCError(ErrInvalidCall)
		return nil, ErrInvalidCall
	}

	if evm.IsEthCallWithoutDestination {
		// Call fake with gas estimation flag set to true since we want to run the constructor
		// as if it was a gas estimation call, that is, without executing the MPC circuit on one hand,
		// but getting a fake execution with "1" values as output.
		log.Trace("Calling contract constructor")
		return c.fakeMPC(signature, true)
	}

	execType := evm.Config.ExecType
	// Placeholder until the real pre-compiles are added so a different state root is generated
	if *execType == Sequencing {
		log.Trace("Execution Type: Sequencing")
		return c.fakeMPC(signature, false)
	}
	if *execType == TranscriptEvaluation {
		log.Trace("Execution Type: Transcript")
		output, err := evm.Config.Transcript.ConsumeExecutionOutput()
		if err != nil {
			log.Error("Error consuming execution output", "err", err, "blockNumber", evm.Config.Header.Number.Int64(), "blockHash", evm.Config.Header.Hash().Hex())
			evm.SetMPCError(err)
			return output, err
		}

		// If the output is equal to the revert output, revert
		if bytes.Equal(output, revertOutput) {
			evm.SetMPCError(ErrExecutionReverted)
			return output, ErrExecutionReverted
		}
		// When offboard processing is used, the resulting ciphertext can be stored in the contract's memory.
		// To ensure consistency across all involved parties, including executors and the sequencer,
		// the ciphertext must be added to the sequencer's authenticated memory, mirroring the action taken by the executors.
		if signature == signatureOffboard || signature == signatureOffboardToUser {
			var tempArr [32]byte
			copy(tempArr[:], output)

			// Insert the cipher-text into the validated cipher-text memory
			insertToAuthenticatedMemory(evm, tempArr)
		}
		return output, nil
	}
	if *execType == MPCExecution {
		log.Trace("Execution Type: Execution")

		if !clientCreated {
			log.Warn("MPC not initialized yet")
			return nil, ErrMPCConnection
		}

		var inputsNumber int

		var output []byte
		var err error

		switch signature {
		case signatureOnboard:
			inputsNumber = 1
			output, err = c.callOnboard(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false, evm)
		case signatureOffboard:
			inputsNumber = 1
			output, err = c.callOffboard(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false, evm)
		case signatureOffboardToUser:
			output, err = c.callOffboardToUser(opName, input[FUNC_SIG_SIZE:], evm)
		case signatureSetPublic:
			inputsNumber = 1
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false)
		case signatureRand:
			output, err = c.callRand(opName, input[FUNC_SIG_SIZE:])
		case signatureRandBoundedBits:
			inputsNumber = 1
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false)
		case signatureDecrypt:
			inputsNumber = 1
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false)
		case signatureMux:
			output, err = c.callMux(opName, input[FUNC_SIG_SIZE:])
		case signatureNot:
			inputsNumber = 1
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], UNIRY_MD_SIZE, false)
		case signatureValidateCiphertext:
			output, err = c.callValidateCiphertext(opName, input[FUNC_SIG_SIZE:], evm, caller, addr)
		case signatureTransfer:
			inputsNumber = 3
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], TRANSFER_MD_SIZE, true)
		case signatureTransferWithAllowance:
			inputsNumber = 4
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], TRANSFERALLOWANCE_MD_SIZE, true)
		case signatureGetKey:
			output, err = c.getUserKey(opName, input[FUNC_SIG_SIZE:], evm)
		case signatureShl:
			output, err = c.callSHL(opName, input[FUNC_SIG_SIZE:])
		case signatureShr:
			output, err = c.callSHR(opName, input[FUNC_SIG_SIZE:])
		case signatureSHA256Fixed432BitInput:
			output, err = c.callSHA256Fixed432BitInput(opName, input[FUNC_SIG_SIZE:])
		default: // A binary operation
			inputsNumber = 2
			output, err = c.callMPC(opName, inputsNumber, input[FUNC_SIG_SIZE:], BINARY_MD_SIZE, true)
		}
		if err != nil {
			log.Error("Error executing MPC", "err", err)
			evm.SetMPCError(err)
			output = revertOutput
		}
		evm.MPCExecutionOutput = append(evm.MPCExecutionOutput, output) // Store output

		return output, err
	}

	log.Error("Invalid execution type")
	evm.SetMPCError(ErrInvalidExecutionType)
	return nil, ErrInvalidExecutionType
}

func (c *mpcContract) fakeMPC(signature uint32, isGasEstimated bool) ([]byte, error) {
	log.Debug("Fake MPC execution")

	var val *big.Int
	if isGasEstimated {
		val = big.NewInt(1)
	} else {
		val = big.NewInt(123)
	}

	// Get the operation based on the signature
	opName, ok := operationNamesMap[signature]
	if !ok {
		log.Error("Method not found")
		return nil, ErrMethodNotFound
	}

	switch signature {

	case signatureSHA256Fixed432BitInput, signatureGetKey:
		// Simulate the RSA encryption output
		temp := val.FillBytes(make([]byte, c.getMPCOutputSize(opName)))
		// Convert to evm bytes
		return toEVMBytes(temp), nil
	default: // A binary operation
		return val.FillBytes(make([]byte, c.getMPCOutputSize(opName))), nil
	}
}

func (c *mpcContract) getMPCOutputSize(opName string) int {
	var outputSize int
	switch opName {

	case "TRANSFER":
		//  Transfer returns two 32-byte big ints and a result boolean
		outputSize = VAR_SIZE * 3
	case "TRANSFERWITHALLOWANCE":
		//  Transfer with allowance returns three 32-byte big ints and a result boolean
		outputSize = VAR_SIZE * 4
	case "GETUSERKEY":
		outputSize = RSA_OUTPUT_SIZE * 2 // Get user key returns two encryptions of key shares
	case "ADDWITHOVERFLOWBIT":
		outputSize = VAR_SIZE * 2 // Add with overflow bit returns two gt's - the output value and the overflow bit
	case "SUBWITHOVERFLOWBIT":
		outputSize = VAR_SIZE * 2 // Sub with overflow bit returns two gt's - the output value and the overflow bit
	case "MULWITHOVERFLOWBIT":
		outputSize = VAR_SIZE * 2 // Multiply with overflow bit returns two gt's - the output value and the overflow bit
	default: // A binary operation
		outputSize = VAR_SIZE
	}

	return outputSize
}

func (c *mpcContract) callMPC(opName string, inputsNumber int, input []byte, metadataSize int, hasTypes bool) ([]byte, error) {
	log.Trace("***********************" + opName + "***********************")

	// Get the input sizes from the metadata
	numSizes := inputsNumber
	// In case there is an input that is not defined in the metadata, take only the inputs that are defined.
	if hasTypes && (inputsNumber > metadataSize-1) {
		numSizes = metadataSize - 1
	}
	if !hasTypes && (inputsNumber > metadataSize) {
		numSizes = metadataSize
	}

	inputSizes := make([]uint32, numSizes)
	for i := 0; i < numSizes; i++ {
		size, err := getSize(input[i])
		if err != nil {
			log.Error("Error getting input size", "err", err)
			return nil, err
		}
		inputSizes[i] = uint32(size)
	}

	// Get the input types parameter (as a byte) if it exists
	inputTypes := byte(0)
	if hasTypes {
		inputTypes = input[metadataSize-1]
	}

	// Parse the inputs if they exist
	inputValues := make([][]byte, inputsNumber)
	var err error
	if inputsNumber > 0 {
		inputValues, err = c.prepareInputs(inputsNumber, input)
		if err != nil {
			log.Error("Error processing inputs", "err", err)
			return nil, err
		}
	}

	return runOpcode(opName, inputSizes, inputsNumber, inputTypes, inputValues)
}

func (c *mpcContract) prepareInputs(inputsNumber int, input []byte) ([][]byte, error) {
	if len(input) != METADATA_SIZE+VAR_SIZE*inputsNumber {
		log.Error("Invalid input format", "Expected", fmt.Sprintf("%s uint256 values and 32 bytes for metadata", strconv.Itoa(inputsNumber)))
		return nil, ErrInvalidInputFormat
	}

	// Split the input into two slices
	inputs, err := splitIntoSlices(input[METADATA_SIZE:], inputsNumber)
	if err != nil {
		log.Error("Error splitting input", "err", err)
		return nil, err
	}

	return inputs, nil
}

func (c *mpcContract) callSHA256Fixed432BitInput(opName string, input []byte) ([]byte, error) {
	log.Trace("CallSHA256Fixed432BitInput")
	inputsNumber := 6
	if len(input) != (inputsNumber-1)*VAR_SIZE+EVM_BYTES_PREFIX_SIZE+ADDR_SIZE+ADDR_PADDING_SIZE {
		log.Error("CallSHA256Fixed432BitInput - Invalid input format", "Expected", fmt.Sprintf("%s uint256 values, 64 bytes for bytes prefix and 20 bytes for address", strconv.Itoa(inputsNumber-1)), "Received", len(input))
		return nil, ErrInvalidInputFormat
	}

	// Split the first inputs (amount, seed1, seed2, padding1, padding2) into slices
	inputValues, err := splitIntoSlices(input[:(inputsNumber-1)*VAR_SIZE], inputsNumber-1)
	if err != nil {
		log.Error("Error splitting input", "err", err)
		return nil, err
	}

	// Get the address
	address, err := copySlice(input, (inputsNumber-1)*VAR_SIZE+EVM_BYTES_PREFIX_SIZE, (inputsNumber-1)*VAR_SIZE+EVM_BYTES_PREFIX_SIZE+ADDR_SIZE)
	if err != nil {
		log.Error("CallSHA256Fixed432BitInput - error while getting address", "err", err)
		return nil, err
	}

	// The MPC expectes VAR_SIZE (32 bytes) for the address parameter, so we need to pad it with zeros
	paddedAddress := make([]byte, ADDR_PADDING_SIZE) // 12 bytes initialized to zero

	// Concatenate the padding and original address slices
	paddedAddress = append(paddedAddress, address...)

	// Append the address to the input values
	inputValues = append(inputValues, paddedAddress)

	// Call the MPC server to run the opcode
	output, err := runOpcode(opName, nil, inputsNumber, 0, inputValues)
	if err != nil {
		log.Error("CallSHA256Fixed432BitInput - Error executing MPC", "err", err)
		return nil, err
	}

	outputBytes := toEVMBytes(output)
	return outputBytes, nil
}

func (c *mpcContract) callSHL(opName string, input []byte) ([]byte, error) {
	// Currently we implement shift using multiplication by power of 2.
	return c.runShift(input, "MUL")
}

func (c *mpcContract) runShift(input []byte, shiftOP string) ([]byte, error) {
	// The second input, which is the shift amount, must be a public value to determine the power of 2.
	// Return an error if the second input is not public.
	inputTypes := input[BINARY_MD_SIZE-1]
	if inputTypes != RHS_PUBLIC {
		log.Error("RunShift - Invalid input format, Expected a public value for the right operand", "inputTypes", inputTypes)
		return nil, ErrInvalidInputFormat
	}

	inputsNumber := 2

	// If the length of the input is not as expected, return an error.
	if len(input) != METADATA_SIZE+VAR_SIZE*inputsNumber {
		log.Error("RunShift - Invalid input format", "Expected", fmt.Sprintf("%s uint256 values and 32 bytes for metadata", strconv.Itoa(inputsNumber)))
		return nil, ErrInvalidInputFormat
	}

	inputSize, err := getSize(input[0]) // Get the size of the first variable.
	if err != nil {
		log.Error("Error getting input size", "err", err)
		return nil, err
	}

	// Split the input into two slices
	inputs, err := splitIntoSlices(input[METADATA_SIZE:], inputsNumber)
	if err != nil {
		log.Error("Error splitting input", "err", err)
		return nil, err
	}

	// Convert the shift value to power of 2
	shift_value := new(big.Int).SetBytes(inputs[1]) // Get the shift value
	if shift_value.Uint64() >= (uint64)(inputSize) {
		log.Debug("RunShift - shift value is bigger than the input size", "shift_value", shift_value, "inputSize", inputSize)
		return c.setPublicZero(inputSize)
	}

	// Create the input sizes vector and set the sizes
	inputSizes := make([]uint32, inputsNumber)

	for i := 0; i < inputsNumber; i++ {
		inputSizes[i] = uint32(inputSize)
	}

	exp_value := new(big.Int).Exp(big.NewInt(2), shift_value, nil) // Calculate 2^shift_value to get the multiplication(SHL)/devision(SHR) value
	exp_bytes := exp_value.FillBytes(make([]byte, VAR_SIZE))       // Convert the value to bytes

	log.Debug("RunShift - shift value", "shift_value", shift_value, "exp_value", exp_value)
	log.Debug("RunShift - mul_bytes", "exp_bytes", exp_bytes)
	// Create the input values vector and set the values
	inputValues := make([][]byte, inputsNumber)

	log.Trace("Shift ", "input 0", inputs[0])
	log.Trace("Shift ", "input 1", exp_bytes)

	inputValues[0] = inputs[0]
	inputValues[1] = exp_bytes

	log.Debug("RunShift", "inputSizes", inputSizes, "inputsNumber", inputsNumber, "inputTypes", inputTypes, "inputValues", inputValues)

	// Call the MPC server to run the opcode
	output, err := runOpcode(shiftOP, inputSizes, inputsNumber, inputTypes, inputValues)

	return output, err
}

func (c *mpcContract) setPublicZero(bitSize int) ([]byte, error) {
	inputsNumber := 1

	// Create the input size vector and set the given size
	inputSizes := []uint32{uint32(bitSize)}

	// Create the input values vector and set the value
	inputValues := make([][]byte, inputsNumber)

	zero_value := new(big.Int).FillBytes(make([]byte, VAR_SIZE)) // Create a zero value
	inputValues[0] = zero_value

	// Call the MPC server to run the opcode
	output, err := runOpcode("SETPUBLIC", inputSizes, inputsNumber, 0, inputValues)

	return output, err
}

func (c *mpcContract) callSHR(opName string, input []byte) ([]byte, error) {
	// Currently we implement shift right using devide by power of 2.
	return c.runShift(input, "DIV")
}

func (c *mpcContract) callMux(opName string, input []byte) ([]byte, error) {
	inputsNumber := 3

	inputSizes := make([]uint32, inputsNumber)
	inputSizes[0] = uint32(1) // Selection bit

	for i := 1; i < inputsNumber; i++ {
		size, err := getSize(input[i-1]) // Get the size of the first variable.
		if err != nil {
			log.Error("Error getting input size", "err", err)
			return nil, err
		}
		inputSizes[i] = uint32(size)
	}

	// Get the input types parameter (as a byte) if it exists
	inputTypes := input[BINARY_MD_SIZE-1]

	// Parse the inputs if they exist
	inputValues, err := c.prepareInputs(inputsNumber, input)
	if err != nil {
		log.Error("Error processing inputs", err)
		return nil, err
	}

	// Call the MPC server to run the opcode
	output, err := runOpcode(opName, inputSizes, inputsNumber, inputTypes, inputValues)
	return output, err
}

func (c *mpcContract) callRand(opName string, input []byte) ([]byte, error) {
	if len(input) != METADATA_SIZE {
		log.Error("CallRand - Invalid input format")
		return nil, ErrInvalidInputFormat
	}
	size, err := getSize(input[0])
	if err != nil {
		log.Error("Error getting input size", "err", err)
		return nil, err
	}
	inputSizes := []uint32{uint32(size)}

	// Call the MPC server to run the opcode
	output, err := runOpcode(opName, inputSizes, 0, 0, nil)

	return output, err
}

func (c *mpcContract) callOffboardToUser(opName string, input []byte, evm *EVM) ([]byte, error) {
	var encryptedValue []byte

	inputsNumber := 2

	if len(input) != METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE+ADDR_SIZE+ADDR_PADDING_SIZE {
		log.Error("CallOffboardToUser - Invalid input format")
		return nil, ErrInvalidInputFormat
	}
	size, err := getSize(input[0]) // Get the size of the first variable.
	if err != nil {
		log.Error("Error getting input size", "err", err)
		return nil, err
	}
	inputSizes := []uint32{uint32(size)}

	inputValues := make([][]byte, inputsNumber)

	hash, err := copySlice(input, METADATA_SIZE, METADATA_SIZE+VAR_SIZE)
	if err != nil {
		log.Error("CallOffboardToUser - error while getting GT value", "err", err)
		return nil, err
	}
	address, err := copySlice(input, METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE, METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE+ADDR_SIZE)
	if err != nil {
		log.Error("CallOffboardToUser - error while getting address", "err", err)
		return nil, err
	}
	inputValues[0] = hash
	inputValues[1] = address

	// Call the MPC server to run the opcode
	encryptedValue, err = runOpcode(opName, inputSizes, inputsNumber, 0, inputValues)
	if err != nil {
		log.Error("CallOffboardToUser - Error running MPC opcode", "err", err)
		return nil, err
	}

	var tempArr [VAR_SIZE]byte
	copy(tempArr[:], encryptedValue)

	// Insert the cipher-text into the validated cipher-text memory
	insertToAuthenticatedMemory(evm, tempArr)

	return encryptedValue, nil
}

func splitIntoSlices(input []byte, inputsNumber int) ([][]byte, error) {
	if inputsNumber <= 0 {
		log.Error("Number of slices must be positive")
		return nil, ErrNegativeNumberOfSlices
	}
	if len(input)%inputsNumber != 0 {
		log.Error("Invalid input format", "Problem", fmt.Sprintf("input is not divided into %d slices", inputsNumber))
		return nil, ErrInvalidInputFormat
	}

	var inputs [][]byte
	size := len(input) / inputsNumber

	for i := 0; i < inputsNumber; i++ {
		in, err := copySlice(input, size*i, size*(i+1))
		if err != nil {
			log.Error("SplitIntoSlices - error while copying slice", "err", err)
			return nil, err
		}
		inputs = append(inputs, in)
	}

	log.Trace("SplitIntoSlices", "inputs", inputs)

	return inputs, nil
}

func (c *mpcContract) getUserKey(opName string, input []byte, evm *EVM) ([]byte, error) {
	buf, err := fromEVMBytes(input)
	if err != nil {
		log.Error("GetUserKey - Error parsing EVM bytes", "err", err)
		return nil, err
	}

	if len(buf) < SIGNATURE_SIZE+MIN_RSA_PUBLIC_KEY_SIZE || len(buf) > SIGNATURE_SIZE+MAX_RSA_PUBLIC_KEY_SIZE {
		log.Error("GetUserKey - Invalid input format")
		return nil, ErrInvalidEVMByteArray
	}

	signature := buf[:SIGNATURE_SIZE]
	signedEK := buf[SIGNATURE_SIZE:]

	user := evm.Origin // Sender address

	// Verify the signature
	ok := verifySignatureAndSigner(user, signedEK, signature)
	if !ok {
		log.Error("Error verifying signature")
		return nil, ErrVerifySignature
	}

	parametersBitSize := make([]uint32, 0)
	// The inputs for the mpc getUserKey are the rsa public key (signedEK), the user address and the signature
	var parameters [][]byte = make([][]byte, 3)
	parameters[0] = signedEK
	parameters[1] = user.Bytes()
	parameters[2] = signature

	output, err := runOpcode(opName, parametersBitSize, 3, 0, parameters)
	if err != nil {
		log.Error("GetUserKey - Error running MPC opcode", "err", err)
		return nil, err
	}

	outputBytes := toEVMBytes(output)
	return outputBytes, nil
}

// - 32 byte integer in big-endian order as offset to the dynamic bytes argument
// - 32 byte integer in big-endian order as length
// - the actual bytes in the `bytes` value
// - add zero byte padding until nearest multiple of 32
func toEVMBytes(input []byte) []byte {
	arrLen := uint64(len(input))
	lenBytes32 := uint256.NewInt(arrLen).Bytes32()
	ret := make([]byte, 32, arrLen+64)
	ret[31] = 0x20                      // Pad according to abi specification, first add big-endian offset of the size
	ret = append(ret, lenBytes32[:]...) // Apend the size of the byte array
	ret = append(ret, input...)         // Apent the actual bytes array
	return ret
}

// The format of the EVMBytes is:
// - 32 byte integer in big-endian order as offset to the dynamic bytes argument
// - 32 byte integer in big-endian order as length of the byte array
// - the actual byte array
func fromEVMBytes(input []byte) ([]byte, error) {
	// Extract the offset of the original byte arrays from the first METADATA_SIZE (32 bytes)
	offsetBytes := input[:METADATA_SIZE]
	offset := new(big.Int).SetBytes(offsetBytes).Int64()

	// According the format of EVMBytes, the first 64 bytes contain the offset and the length of the input.
	// In case the input length is less than 64 bytes, return an error.
	if len(input) < METADATA_SIZE*2 {
		log.Error("Input is not a valid EVM byte array")
		return nil, ErrInvalidEVMByteArray
	}

	size := new(big.Int).SetBytes(input[METADATA_SIZE : METADATA_SIZE*2]).Int64()

	if (offset < 0) || (size < 0) {
		log.Error("Invalid offset or size", "offset", offset, "size", size)
		return nil, ErrInvalidEVMByteArray
	}

	if uint64(len(input)) < uint64(offset) {
		log.Error("Input is not a valid EVM byte array")
		return nil, ErrInvalidEVMByteArray
	}

	if uint64(len(input)-METADATA_SIZE*2) < uint64(size) {
		log.Error("Input is not a valid EVM byte array")
		return nil, ErrInvalidEVMByteArray
	}

	log.Debug("FromEVMBytes", "offset", offset, "size", size)
	// Ensure input has sufficient length for the original byte array
	if int64(len(input)) < METADATA_SIZE+offset+size {
		log.Error("Input is not a valid EVM byte array")
		return nil, ErrInvalidEVMByteArray
	}

	// Extract the first byte array
	buf := input[METADATA_SIZE+offset : METADATA_SIZE+offset+size]
	return buf, nil
}

func (c *mpcContract) callOnboard(opName string, inputsNumber int, input []byte, metadataSize int, hasTypes bool, evm *EVM) ([]byte, error) {
	if len(input) < METADATA_SIZE+VAR_SIZE {
		log.Error("CallOnboard - Invalid input format")
		return nil, ErrInvalidInputFormat
	}

	encryptedValue := input[METADATA_SIZE : METADATA_SIZE+VAR_SIZE]

	// Check first that the cipher-text is valid
	var tempArr [32]byte
	copy(tempArr[:], encryptedValue)
	if !isValidInAuthenticatedMemory(evm, [VAR_SIZE]byte(tempArr)) {
		log.Error("CallOnboard - Invalid cipher-text")
		return nil, ErrInvalidCT
	}

	return c.callMPC(opName, inputsNumber, input, metadataSize, hasTypes)
}

func (c *mpcContract) callValidateCiphertext(opName string, input []byte, evm *EVM, caller common.Address, addr common.Address) ([]byte, error) {
	// First check that the call depth is 1, otherwise return an error
	if evm.depth != 1 {
		log.Error("CallValidateCiphertext - Invalid call depth")
		return nil, ErrInavlidCallDepth
	}
	// Get relevant parms
	funcSig := evm.funcSig
	user := evm.Origin

	if len(input) != METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE+SIGNATURE_SIZE+SIGNATURE_PADDING_SIZE {
		log.Error("CallValidateCiphertext - Invalid input format")
		return nil, ErrInvalidInputFormat
	}

	// Get the ciphertext
	ct := input[METADATA_SIZE : METADATA_SIZE+VAR_SIZE]

	signature := input[METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE : METADATA_SIZE+VAR_SIZE+EVM_BYTES_PREFIX_SIZE+SIGNATURE_SIZE]

	// The signature for input-text is of user+contractAddr+funcSig+ct, verify the signature
	// For these specific aruments provided as a message to the signature
	if !verifyIT(user, caller[:], funcSig[:], ct, signature) {
		log.Error("CallValidateCiphertext - Invalid signature")
		return nil, ErrInvalidSignature
	}

	// Onboard the ciphertext
	output, err := c.callOnboardIT(opName, input, evm)
	if err != nil {
		log.Error("Error onboarding ciphertext", "err", err)
		return nil, err
	}

	return output, nil
}

func (c *mpcContract) callOnboardIT(opName string, input []byte, evm *EVM) ([]byte, error) {
	log.Trace("***********************", opName, "IT ***********************")
	inputsNumber := 2

	size, err := getSize(input[0])
	if err != nil {
		log.Error("Error getting input size", "err", err)
		return nil, err
	}
	inputSizes := []uint32{uint32(size)}

	inputValues := make([][]byte, inputsNumber)

	// Set the pointer in the array to the input and address
	encryptedValue := input[METADATA_SIZE : METADATA_SIZE+VAR_SIZE]
	address := evm.Origin.Bytes()

	inputValues[0] = encryptedValue
	inputValues[1] = address

	// Call the MPC server to run the opcode
	output, err := runOpcode(opName, inputSizes, inputsNumber, 0, inputValues)

	return output, err
}

func (c *mpcContract) callOffboard(opName string, inputsNumber int, input []byte, metadataSize int, hasTypes bool, evm *EVM) ([]byte, error) {
	var encryptedValue []byte
	var err error
	// In gas estimation we need not do any encryption

	encryptedValue, err = c.callMPC(opName, inputsNumber, input, metadataSize, hasTypes)
	if err != nil {
		log.Error("Error calling MPC", "err", err)
		return nil, err
	}

	var tempArr [VAR_SIZE]byte
	copy(tempArr[:], encryptedValue)

	// Insert the cipher-text into the validated cipher-text memory
	insertToAuthenticatedMemory(evm, tempArr)

	return encryptedValue, nil
}

func copySlice(input []byte, start, end int) ([]byte, error) {
	if (start < 0) || (end > len(input)) || (start > end) {
		log.Error("Invalid input format")
		return nil, ErrInvalidInputFormat
	}
	newSlice := make([]byte, end-start)
	copy(newSlice, input[start:end])
	return newSlice, nil
}

// decrypt computes AES(k, r) XOR ciphertext to obtain the original plaintext.
// The function returns the resulting decrypted plaintext.
func decrypt(key, r, ct []byte) ([]byte, error) {
	// Create a new AES cipher block using the provided key
	block, err := aes.NewCipher(key)
	if err != nil {
		log.Error("Failed to create AES cipher block", "err", err)
		return nil, fmt.Errorf("failed to create AES cipher block: %v", err)
	}

	// Check that the random value 'r' is exactly 16 bytes
	if len(r) != aes.BlockSize {
		log.Error("Random value 'r' must be exactly 16 bytes", "r length", len(r))
		return nil, fmt.Errorf("random value 'r' must be exactly 16 bytes")
	}

	// Check that the ciphertext 'ct' is a multiple of the block size
	if len(ct)%aes.BlockSize != 0 {
		log.Error("Ciphertext 'ct' must be a multiple of the block size")
		return nil, fmt.Errorf("ciphertext 'ct' must be a multiple of the block size")
	}

	// Create a temporary buffer to hold the encrypted random value 'r'
	encryptedR := make([]byte, aes.BlockSize)

	// Encrypt the random value 'r' using AES in ECB mode
	block.Encrypt(encryptedR, r)

	// XOR the encrypted random value 'r' with the ciphertext to obtain the plaintext
	plaintext := make([]byte, len(ct))
	for i := range encryptedR {
		plaintext[i] = encryptedR[i] ^ ct[i]
	}

	return plaintext, nil
}

func writeNetworkAESKey(filePath string, key []byte) error {
	// Ensure the key is the correct length (16 bytes for AES-128)
	if len(key) != 16 {
		log.Error("Invalid key length, must be 16 bytes", "key length", len(key))
		return fmt.Errorf("invalid key length: %d bytes, must be 16 bytes", len(key))
	}

	// Encode the key to hex string
	hexKey := hex.EncodeToString(key)

	// Write the hex-encoded key to the file
	if err := os.WriteFile(filePath, []byte(hexKey), 0644); err != nil {
		log.Error("Failed to write key to file", "err", err)
		return fmt.Errorf("failed to write key to file: %v", err)
	}

	return nil
}

// Generates a random 128-bit AES key
func generateAESKey() ([]byte, error) {
	// Generate a random 128-bit AES key
	key := make([]byte, 16)
	if _, err := rand.Read(key); err != nil {
		log.Error("Failed to generate AES key", "err", err)
		return nil, fmt.Errorf("failed to generate AES key: %v", err)
	}

	return key, nil
}

// Writes the given AES key to the given file path in hex format.
func writeAESKey(key []byte, path string) error {
	// Write the key to the file
	if err := writeNetworkAESKey(path, key); err != nil {
		log.Error("Failed to write key to file", "err", err)
		return fmt.Errorf("failed to write key to file: %v", err)
	}

	return nil
}

// Deleted the given AES key file at the given path
func deleteAESKey(path string) error {
	// Attempt to remove the file
	err := os.Remove(path)
	if err != nil {
		return err
	}

	return nil
}

func verifyIT(user common.Address, addr, funcSig, ct, signature []byte) bool {

	// Create the message to be signed by appending all inputs
	message := append(user.Bytes(), addr...)
	message = append(message, funcSig...)
	message = append(message, ct...)

	return verifySignatureAndSigner(user, message, signature)
}

func concat(parts ...[]byte) []byte {
	var combined []byte
	for _, part := range parts {
		combined = append(combined, part...)
	}
	return combined
}

func updateMessageWithPrefix(message []byte) []byte {
	messageLength := strconv.Itoa(len(message))
	// Concatenate the prefix, message length, and the message
	return concat(
		[]byte(MESSAGE_PREFIX),
		[]byte(messageLength),
		message,
	)
}

// updateSignature adjusts the last byte of the provided ECDSA signature.
//
// In Ethereum, the `v` value (the 65th byte in the signature) is often encoded as
// either 27 or 28. This function normalizes the `v` value by subtracting 27 from it,
// resulting in a `v` value of either 0 or 1, which is commonly used in cryptographic
// libraries.
//
// This function directly modifies the input slice, so the original `signature` slice
// will be altered. It returns the modified signature slice for convenience.
func updateSignature(signature []byte) []byte {
	signature[64] -= 27
	return signature
}

func verifySignatureAndSigner(user common.Address, message, signature []byte) bool {

	// Hash the concatenated message using Keccak-256
	hash := crypto.Keccak256(message)

	pubkey, err := crypto.Ecrecover(hash, signature)
	if err != nil {
		// Update the message and signature with the prefix to match the Ethereum signature format (EIP-191)
		// and try to recover the public key again
		message = updateMessageWithPrefix(message)
		signature = updateSignature(signature)
		hash = crypto.Keccak256(message)
		pubkey, err = crypto.Ecrecover(hash, signature)
		if err != nil {
			log.Error("Ecrecover failed to recover public key:", err)
			return false
		}
	}

	// Use the public key to generate a Keccak-256 hash
	pubKeyHash := crypto.Keccak256(pubkey[1:]) // omit the 0x04 prefix byte

	// The Ethereum address is the last 20 bytes of the Keccak-256 hash
	var signer common.Address
	copy(signer[:], pubKeyHash[12:]) // Copy the last 20 bytes

	if signer != user {
		return false
	}

	return crypto.VerifySignature(pubkey, hash, signature[:64])
}

func encryptRSA(publicKeyBytes []byte, message []byte) ([]byte, error) {

	// Parse public key from DER format
	publicKey, err := x509.ParsePKIXPublicKey(publicKeyBytes)
	if err != nil {
		log.Error("Error parsing public key", "err", err)
		return nil, err
	}

	// Type assert parsed key to *rsa.PublicKey
	rsaPublicKey, ok := publicKey.(*rsa.PublicKey)
	if !ok {
		log.Error("Error type asserting public key")
		return nil, err
	}
	// Encrypt message using RSA public key with OAEP padding
	ciphertext, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, rsaPublicKey, message, nil)
	if err != nil {
		log.Error("Error encrypting message", "err", err)
		return nil, err
	}

	return ciphertext, nil

}
